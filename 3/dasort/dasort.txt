It never ask for the order of a delete and append operation.
You can therefor assume that the list of every element delete will be itself sorted.
original array
Some deletion occurs
kept array | deleted array
There is two condition that we want to be true.
First, the kept array is sorted. (The element we chose not to delete are themself sorted)
Second we want the biggest element of the kept array to be smaller or equal the biggest element of the deleted array
So kept[-1] <= deleted[0]
The problem become to ensure both condition are true with the minimal amount of deletion.
First step deal with the input
Second sort a copy (noted s) of the array of terms (noted d).
Start a counter, j=0
foreach term i in d, increment j iff s[j]==i
At the end print len(d)-j

Why does this endure both condition?
j count how many of term have not being deleted.
Meaning 1st) the kept array up until that point is sorted
2nd) no number goes in between the element kept.

How does this ensure the second condition?
Well we only keep if s[j] == our cur.
If we have deleted previously s[j] then this condition will never be true.
We will keep deleted until the end of the array.
The last term we kept will be s[j-1] and the smallest term we have deleted will be s[j]
s is sorted => kept[-1] <= deleted[0]